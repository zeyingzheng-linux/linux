/*
1.  请简述Linux内核在理想情况下页面分配器(page allocator)是如何分配出连续物理页面的？

    首先 __alloc_pages默认是按照Low水位去申请内存的，快速路径走的就是这条路子，所以一开始
    从首选的zone(highest_zoneidx)开始，从高往低去扫，看是否可以满足分配条件，条件判断则是
    是否满足各种计算出来的Low水位，然后再看当前扫的zone上有无符合order的空间，如果没有，再
    去看当前zone的其他迁移类型有无符合order的空间，但凡一个满足，则认为是有能力分配的，即
    达到分配标准了。调用 rmqueue从当前zone分配页面，当前的迁移类型不满足就借用备用的迁移类型
    记住，快速分配路径也有可能唤醒 kswapd，如果你设置了 ZONE_BOOSTED_WATERMARK的话。


2.  在页面分配器中，如何从分配掩码(gfp_mask)中确定可以从哪些zone中分配内存？

    gfp_zone：The zone fallback order is MOVABLE=>HIGHMEM=>NORMAL=>DMA32=>DMA.

3.  页面分配器是按照什么方向来扫描zone的？

    从首选的zone(highest_zoneidx)开始，从高往低去扫。

4.  为用户进程分配物理内存时，分配掩码应该选用 GFP_KERNEL还是 GFP_HIGHUSER_MOVABLE呢？

    当然是选用 GFP_HIGHUSER_MOVABLE啦，这样才可以移动嘛，内存规整需要可移动的，CMA也是。

5.  在中断上下文中能不能调用包含 GFP_KERNEL分配掩码的内存分配函数？

    不可以，因为 GFP_KERNEL分配掩码可能会导致睡眠，在中断上下文是不允许睡眠的。

6.  如何判断一个zone是否符合分配需求？

    首先是看水线，水线过了之后就看zone的所有迁移类型中是否有一个可以满足order要求。
 
7.  在释放页面时，页面分配器是如何进行空闲页面合并的？

    free_page可以根据参数page找到是属于哪个迁移类型的，然后又根据page的order等参数找到自己
    的buddy，看buddy是否空闲，如果是就合并成一个大块，如此循环反复，等到自己的buddy不为空闲
    的时候，就把自己挂入自己属于的哪个迁移类型的空闲链表，自己是order多少次方，则是看命了。
 
8.  在早期的Linux内核中，以2^n字节为大小的内存块分配机制有什么缺点？slab机制如何克服这些缺点？ 

    前期实现的以2^n字节大小的内存块分配机制类似于伙伴系统，这个简单的机制虽然减少了内存浪费，
    但是并不高效。slab有如下优点：
    1) 把分配的内存块当做对象(object)来看待。对象可以自定义构造函数(constructor)和析构函数(
    destructor)来初始化对象的内容并释放对象的内容。
    2) slab对象被释放之后不会马上丢弃而是继续保留在内存中，可能稍后会被用到，这样不需要重新
    向伙伴系统申请内存。
    3) slab机制可以根据特定大小的内存块来创建slab描述符，如内存中常见的数据结构、打开文件对象
    等，这样可以有效的避免内存碎片的产生，也可以快速获得频繁访问的数据结构。另外，slab机制也
    支持按照2^n字节大小分配内存块。
    4) slab机制创建了多层的缓冲池，充分利用了空间换时间的思想，未雨绸缪，有效的解决了效率问题
    	1> 每个CPU有本地对象缓冲池，避免了多核之间的锁征用问题
	2> 每个内存节点有共享对象缓冲池。
 
9.  slab分配器是如何分配和释放小内存块的？
10. slab分配器中有一个高速缓存着色的概念，着色有什么作用？
11. slab分配器增长并导致大量不用的空闲对象产生，该如何解决？
12. 什么是对象缓冲池？
13. 在创建一个slab对象描述符时，如何确定一个slab占用多少个物理页面、有多少个对象、着色区有多少？
14. slab分配器的布局有三种模式 -- 正常模式、OBJFREELIST_SLAB模式、OFF_SLAB模式，它们有什么区别？
15. 什么时候给slab分配器分配物理内存？
16. slab分配器中有一个slab管理区域freelist，那么这个slab管理区域是如何管理空闲对象的？
17. slab分配器是如何保证在多CPU的大型计算机中的并发访问性能的？

18. kmalloc、vmalloc、malloc之间有什么区别以及实现上的差异？
19. Linux内核是如何管理进程的用户态地址空间的？
20. 进程地址空间的属性是如何转换成硬件能识别的属性？
21. 进程地址空间是离散的，那Linux内核如何保证这些地址空间不会冲突？
22. Linux如何实现进程地址空间的快速查询和插入？
23. find_vma函数查找符合哪些条件的VMA？
24. malloc函数返回的内存是否马上就会被分配物理内存？testA和testB分配在何时分配物理内存？
25. 假设不考虑libc的因素，malloc分配100字节，那么实际上内核为其分配100字节吗？
26. 假设printf输出的指针bufA和bufB指向的地址是一样的，那么在内核中者两个虚拟内存块是否冲突？
27. vm_normal_page函数返回什么页面的page数据结构？为什么内存管理代码中需要这个函数？
28. 请简述get_user_pages函数的作用和实现流程。
29. 请简述follow_page函数的作用和实现流程。
30. SYSCALL_DEFINE1(brk, unsigned long, brk)这个宏是如何展开的？
31. 在ARM64内核中，用户空间是如何划分的？brk区域的起始地址和结束地址在哪里？
32. 请简述私有映射和共享映射的区别。
33. 在以下代码中，为什么第二次调用mmap时，Linux内核没有捕捉到地址重叠并返回失败呢？
    #strace 捕捉某个app调用mmap的情况
    mmap(0x20000000, 819200, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXDE | MAP_ANONYMOUS,
		    -1, 0) = 0x20000000
    ...
    mmap(0x20000000, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXDE | MAP_ANONYMOUS,
		    -1, 0) = 0x20000000
34. 请简述ARM64处理器在缺页异常发生之后是如何找到发生异常的类型和错误地址的。
35. 当ARM64处理器发生了缺页异常时，如何知道它是因为读内存还是写内存发生的缺页异常？
36. 当处理器发生了缺页异常时，如何判断发生异常的地址是可以修复的还是不可以修复的？
37. 在do_page_fault函数处理过程中需要考虑哪些情况？
38. major fault 和 minor fault有什么区别？
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 */
